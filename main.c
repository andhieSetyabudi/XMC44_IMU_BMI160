/*******************************************************************************
* File Name:   main.c
*
* Description: This code example demonstrates the implementation of an I2C 
*              master and an I2C slave using the Universal Serial Interface
*              Channel (USIC) module available in XMC MCUs. It configures one
*              USIC module as I2C master and another one as I2C slave on the
*              same XMC MCU using the device configurator. I2C master module
*              sends commands to the I2C slave module to toggle the LEDs present
*              on XMC development kit. User has to make the connection between
*              I2C master and I2C slave externally.
*
* Related Document: See README.md
*
********************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*                                                                              
*****************************************************************************/

#include <bmi160.h>
#include <bmi160_defs.h>
#include "cybsp.h"
#include "cy_utils.h"

#include "cy_retarget_io.h"

/*******************************************************************************
* Defines
*******************************************************************************/

#define DEBUG_LOOP_COUNT_MAX                (1U)

/* SysTick timer frequency in Hz  */
#define TICKS_PER_SECOND           1000

/* I2C Master sends every 500ms a command to toggle LED on slave */
#define I2C_MASTER_SEND_TASK_MS    500

/* 8-bit command patterns to set LED port on slave to high/low */
#define CMD_LED_HIGH               0xaa
#define CMD_LED_LOW                0x55

/* I2C receive event interrupt priority */
#define I2C_RECEIVE_EVENT_PRIORITY 63

/*******************************************************************************
* Global Variables
*******************************************************************************/
/* Variable for keeping track of time */
static volatile uint32_t ticks = 0;

/*******************************************************************************
* Function Name: SysTick_Handler
********************************************************************************
* Summary:
* This is the interrupt handler function for the SysTick timer interrupt.
* It counts the time elapsed in milliseconds since the timer started.
* Every I2C_MASTER_SEND_TASK_MS milliseconds, an I2C-command is sent from
* I2C-master to I2C-slave to toggle a LED.
*
* Parameters:
*  none
*
* Return:
*  none
*
*******************************************************************************/
void SysTick_Handler(void)
{
//    static uint8_t tx_master_send = CMD_LED_LOW;
    static uint32_t ticks = 0;
    ticks++;
//    if (ticks == I2C_MASTER_SEND_TASK_MS)
//    {
//        /* Prepare command to toggle LED on I2C slave */
//        switch (tx_master_send)
//        {
//            case CMD_LED_LOW:
//            {
//                tx_master_send = CMD_LED_HIGH;
//            }
//            break;
//            case CMD_LED_HIGH:
//            {
//                tx_master_send = CMD_LED_LOW;
//            }
//            break;
//        }
//
//        /* Send START conditon */
//      //  XMC_I2C_CH_MasterStart(I2C_MASTER_HW, I2C_SLAVE_SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
//
//        /* Wait for acknowledge and reset status */
//        while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_HW) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
//        {
//            /* wait for ACK from slave */
//        }
//
//        XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_HW,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
//
//        /* Transmit next command from I2C master to I2C slave */
//        XMC_I2C_CH_MasterTransmit(I2C_MASTER_HW, tx_master_send);
//
//        /* Wait for acknowledge and reset status */
//        while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_HW) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
//        {
//            /* wait for ACK from slave */
//        }
//
//        XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_HW,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
//
//        /* Wait until TX FIFO is empty */
//        while (!XMC_USIC_CH_TXFIFO_IsEmpty(I2C_MASTER_HW))
//        {
//            /* wait until all data is sent by HW */
//        }
//
//        /* Send STOP conditon */
//        XMC_I2C_CH_MasterStop(I2C_MASTER_HW);
//
//        /* Reset ticks counter */
//        ticks = 0;
//    }
}

/*! @brief This structure containing relevant bmi160 info */
struct bmi160_dev bmi160dev;

/*! @brief variable to hold the bmi160 accel data */
struct bmi160_sensor_data bmi160_accel;

/*! @brief variable to hold the bmi160 gyro data */
struct bmi160_sensor_data bmi160_gyro;

int8_t i2c_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *pData, uint16_t len);
int8_t i2c_read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *data, uint16_t len);
void delay_wrapper(uint32_t ms);

void init_sensor_interface(void);

void update_sensor();
/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function.
* The I2C master and slave interface are initialized using personalities.
* Interrupt priority is set for the receive event of the I2C slave.
* Systick timer is initialized to call SysTick_Handler every 1 ms.
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/
int main(void)
{
    cy_rslt_t result;

    /* Initialize the device and board peripherals */
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    cy_retarget_io_init(CYBSP_DEBUG_UART_HW);
    printf("UART Initialization done\r\n");
    init_sensor_interface();
    /* System timer configuration */
    SysTick_Config(SystemCoreClock / TICKS_PER_SECOND);
    while(1)
    {
    	XMC_Delay(1000);
    	update_sensor();

    }
}


int8_t i2c_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *pData, uint16_t len)
{
	uint8_t time_count = 0;
	XMC_I2C_CH_MasterStart(I2C_MASTER_HW, (const uint16_t) dev_addr, XMC_I2C_CH_CMD_WRITE);
	while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_HW) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
	{
		/* wait for ACK from slave */
		delay_wrapper(1);
		time_count++;
		if(time_count >= 20 )
			return (BMI160_E_COM_FAIL);
	};
	XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_HW,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);

	// push data to FIFO buffer
	for(uint16_t i = 0; i<len; i++)
		XMC_I2C_CH_MasterTransmit(I2C_MASTER_HW, pData[i]);

	time_count = 0;
	/* Wait for acknowledge and reset status */
	while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_HW) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
	{
		/* wait for ACK from slave */
		delay_wrapper(1);
		time_count++;
		if(time_count >= 20 )
			return (BMI160_E_COM_FAIL);
	}

	XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_HW,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);

	time_count = 0;
	/* Wait until TX FIFO is empty */
	while (!XMC_USIC_CH_TXFIFO_IsEmpty(I2C_MASTER_HW))
	{
		/* wait until all data is sent by HW */
		delay_wrapper(1);
		time_count++;
		if(time_count >= 20 )
			return (BMI160_E_COM_FAIL);
	}

	/* Send STOP conditon */
	XMC_I2C_CH_MasterStop(I2C_MASTER_HW);
	return BMI160_OK;


}

int8_t i2c_read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *data, uint16_t len)
{
	uint8_t time_count = 0;
	XMC_I2C_CH_MasterStart(I2C_MASTER_HW, (const uint16_t) dev_addr, XMC_I2C_CH_CMD_WRITE);
	while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_HW) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
	{
		/* wait for ACK from slave */
		delay_wrapper(1);
		time_count++;
		if(time_count >= 20 )
			return (BMI160_E_COM_FAIL);
	};
	XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_HW,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);

	// push data to FIFO buffer
	XMC_I2C_CH_MasterTransmit(I2C_MASTER_HW, reg_addr);

	time_count = 0;
	/* Wait for acknowledge and reset status */
	while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_HW) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
	{
		/* wait for ACK from slave */
		delay_wrapper(1);
		time_count++;
		if(time_count >= 20 )
			return (BMI160_E_COM_FAIL);
	}

	XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_HW,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);

	time_count = 0;
	/* Wait until TX FIFO is empty */
	while (!XMC_USIC_CH_TXFIFO_IsEmpty(I2C_MASTER_HW))
	{
		/* wait until all data is sent by HW */
		delay_wrapper(1);
		time_count++;
		if(time_count >= 20 )
			return (BMI160_E_COM_FAIL);
	}

	// send re-start
	XMC_I2C_CH_MasterRepeatedStart(I2C_MASTER_HW, (const uint16_t) dev_addr, XMC_I2C_CH_CMD_READ);
	while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_HW) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
	{
		/* wait for ACK from slave */
		delay_wrapper(1);
		time_count++;
		if(time_count >= 20 )
			return (BMI160_E_COM_FAIL);
	};
	XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_HW,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
	for(uint16_t i = 0; i<len-1; i++)
	{
		data[i]=XMC_I2C_CH_GetReceivedData(I2C_MASTER_HW);
		XMC_I2C_CH_MasterReceiveAck(I2C_MASTER_HW);
	}
	data[len-1]=XMC_I2C_CH_GetReceivedData(I2C_MASTER_HW);

	XMC_I2C_CH_MasterReceiveNack(I2C_MASTER_HW);
	XMC_I2C_CH_MasterStop(I2C_MASTER_HW);
	return BMI160_OK;
}

void delay_wrapper(uint32_t ms)
{
    (void)XMC_Delay(ms);
}

void init_sensor_interface(void){
	bmi160dev.write = i2c_write;
	bmi160dev.read = i2c_read;
	bmi160dev.delay_ms = delay_wrapper;

	/* set correct i2c address */
	bmi160dev.id = BMI160_I2C_ADDR<<1;
	bmi160dev.intf = BMI160_I2C_INTF;
	int8_t rslt;
//	default_param_settg(&bmi160dev);
	rslt = bmi160_init(&bmi160dev);

	if (rslt == BMI160_OK)
	{
		printf("BMI160 initialization success !\n");
		printf("Chip ID 0x%X\n", bmi160dev.chip_id);
	}
	else
	{
		printf("BMI160 initialization failure !\n");
	}

	struct bmi160_acc_step_detect_int_cfg det= {
			.step_detector_en = BMI160_ENABLE,
			.step_detector_mode = BMI160_STEP_DETECT_NORMAL,
	};

	// initialize for step count
	struct bmi160_int_settg int_config;
	/* Select the Interrupt channel/pin */
	  int_config.int_channel = BMI160_INT_CHANNEL_1; // Interrupt channel/pin 1

	  /* Select the Interrupt type */
	  int_config.int_type = BMI160_STEP_DETECT_INT;

	  /* Select the interrupt channel/pin settings */
	  int_config.int_pin_settg.output_en = BMI160_DISABLE;         // na - Enabling interrupt pins to act as output pin
	  int_config.int_pin_settg.output_mode = BMI160_DISABLE;      // na - Choosing push-pull mode for interrupt pin
	  int_config.int_pin_settg.output_type = BMI160_ENABLE;       // na - Choosing active High output
	  int_config.int_pin_settg.edge_ctrl = BMI160_ENABLE;         // na - Choosing edge triggered output
	  int_config.int_pin_settg.input_en = BMI160_DISABLE;         // na - Disabling interrupt pin to act as input
	  int_config.int_pin_settg.latch_dur = BMI160_LATCH_DUR_10_MILLI_SEC; // na - non-latched output

	  int_config.int_type_cfg.acc_step_detect_int.min_threshold = 0;
	  int_config.int_type_cfg.acc_step_detect_int.step_detector_en = BMI160_ENABLE;               // na - 1-enable, 0-disable the step detector
	  int_config.int_type_cfg.acc_step_detect_int.step_detector_mode = BMI160_STEP_DETECT_SENSITIVE;
	  int_config.int_type_cfg.acc_step_detect_int.step_min_buf = 0;
	  int_config.int_type_cfg.acc_step_detect_int.steptime_min = 0;
	bmi160_set_int_config(&int_config, &bmi160dev);
	bmi160_set_step_counter(1, &bmi160dev);

	// setup for axis
	/* Select the Output data rate, range of accelerometer sensor */
	bmi160dev.accel_cfg.odr = BMI160_ACCEL_ODR_1600HZ;
	bmi160dev.accel_cfg.range = BMI160_ACCEL_RANGE_16G;
	bmi160dev.accel_cfg.bw = BMI160_ACCEL_BW_NORMAL_AVG4;

	/* Select the power mode of accelerometer sensor */
	bmi160dev.accel_cfg.power = BMI160_ACCEL_NORMAL_MODE;

	/* Select the Output data rate, range of Gyroscope sensor */
	bmi160dev.gyro_cfg.odr = BMI160_GYRO_ODR_3200HZ;
	bmi160dev.gyro_cfg.range = BMI160_GYRO_RANGE_2000_DPS;
	bmi160dev.gyro_cfg.bw = BMI160_GYRO_BW_NORMAL_MODE;

	/* Select the power mode of Gyroscope sensor */
	bmi160dev.gyro_cfg.power = BMI160_GYRO_NORMAL_MODE;
	bmi160_set_sens_conf(&bmi160dev);

}

void update_sensor()
{
	if( bmi160_get_sensor_data((BMI160_ACCEL_SEL | BMI160_GYRO_SEL), &bmi160_accel, &bmi160_gyro, &bmi160dev) == BMI160_OK)
	{
		printf("ax:%d\tay:%d\taz:%d\r\n", bmi160_accel.x, bmi160_accel.y, bmi160_accel.z);
		printf("gx:%d\tgy:%d\tgz:%d\r\n", bmi160_gyro.x, bmi160_gyro.y, bmi160_gyro.z);
	}
	static uint16_t  count = 0;
	if( bmi160_read_step_counter(&count,&bmi160dev) == 0)
		printf("Step count %d\r\n", count);
}

/* [] END OF FILE */
